col.pal = c(Freebayes="#00798c",Lofreq="#d1495b",Varscan="edae49",BreseQ="#66a182")
check <- matrix(random_sample,nrow=4,
dimnames = list(c("Freebayes","Lofreq","Varscan", "BreseQ"),
c("breseq","BWA","Minimap")))
chordDiagram(check,grid.col = col.pal)
col.pal = c(Freebayes="#00798c",Lofreq="#d1495b",Varscan="edae49",BreseQ="#66a182")
col.pal = c(Freebayes="#00798c",Lofreq="#d1495b",Varscan="#edae49",BreseQ="#66a182")
check <- matrix(random_sample,nrow=4,
dimnames = list(c("Freebayes","Lofreq","Varscan", "BreseQ"),
c("breseq","BWA","Minimap")))
chordDiagram(check,grid.col = col.pal)
col.pal = c(Freebayes="#00798c",Lofreq="#d1495b",Varscan="#edae49",BreseQ="#66a182",
breseq="#2e4057", BWA="#8d96a3")
check <- matrix(random_sample,nrow=4,
dimnames = list(c("Freebayes","Lofreq","Varscan", "BreseQ"),
c("breseq","BWA","Minimap")))
chordDiagram(check,grid.col = col.pal)
col.pal = c(Freebayes="#00798c",Lofreq="#d1495b",Varscan="#edae49",BreseQ="#66a182",
breseq="#2e4057", BWA="#8d96a3", Minimap= "#b7bdc5")
check <- matrix(random_sample,nrow=4,
dimnames = list(c("Freebayes","Lofreq","Varscan", "BreseQ"),
c("breseq","BWA","Minimap")))
chordDiagram(check,grid.col = col.pal)
col.pal = c(Freebayes="#00798c",Lofreq="#d1495b",Varscan="#edae49",BreseQ="#66a182",
breseq="#2e4057", BWA="#8d96a3", Minimap= "#c9cdd4")
check <- matrix(random_sample,nrow=4,
dimnames = list(c("Freebayes","Lofreq","Varscan", "BreseQ"),
c("breseq","BWA","Minimap")))
chordDiagram(check,grid.col = col.pal)
chordDiagram(check,
preAllocateTracks = list(list(track.height=  uh(3,"mm")   ), # outside track for names
list(track.height=  uh(10,"mm")    )), # middle track for regions
grid.col = col.pal)
chordDiagram(check,
preAllocateTracks = list(list(track.height=  uh(3,"mm")), # outside track for names
list(track.height=  uh(10,"mm"))), # middle track for regions
annotationTrack = "grid",
grid.col = col.pal)
chordDiagram(check,
preAllocateTracks = list(list(track.height=  uh(3,"mm")), # outside track for names
list(track.height=  uh(10,"mm"))), # middle track for regions
grid.col = col.pal)
library(ggtext)
library(cowplot)
library(fiftystater) # states
library(PNWColors) # colors
devtools::install_github("wmurphyrd/fiftystater")
library(ggtext)
library(cowplot)
library(fiftystater) # states
library(PNWColors) # colors
descriptions <- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2019/2019-12-17/dog_descriptions.csv')
# Step 2. Set Theme
#--- --- --- --- --- --- --- --- --- ---
theme_set(theme_void(base_size = 12))
theme_update(plot.background   =element_rect(fill = "grey15"),
panel.background = element_blank(),
plot.title = element_text(size = rel(2.3),
family = "Helvetica Neue Thin",
hjust = 0.5,
color="grey75"),
plot.subtitle = element_text(size = rel(1),
family = "Helvetica Neue Thin",
color = "grey75",
lineheight = 1.4,
hjust = 0.5),
plot.caption = element_text(size = rel(.75),
family = "Bitter",
color = "grey50"),
legend.position = "bottom",
legend.justification = "center",
legend.text = element_text(size = rel(1),
family = "Helvetica Neue Thin",
color="grey75")
)
# Step 3. Build tools
#--- --- --- --- --- --- --- --- --- ---
names(state.abb) <- state.name # connect state abb and state name. will use later.
names(state.name) <- state.abb # connect state abb and state name. will use later.
Mode <- function(x) { #create "mode" function
ux <- unique(x)
ux[which.max(tabulate(match(x, ux)))]
}
pal <- pnw_palette("Winter",6)
# Step 4. Clean and plot
#--- --- --- --- --- --- --- --- --- ---
dogmap <- descriptions %>%
filter(contact_state %in% state.abb) %>% # remove those with atypical state codes
group_by(contact_state) %>%
summarise( total = n(),  # number per state
breed = Mode(breed_primary)) %>%  #mode of breed
rename(state = contact_state) %>%
filter(!is.na(breed)) %>%  #remove no breed dogs
mutate(id = tolower(state.name[state])) %>% # match state abb to state name and change to lower case
left_join(fifty_states,by="id") %>% #
ggplot(aes(x = long, y = lat,
group = group, fill = breed))+
geom_polygon(color="black")+
scale_fill_manual(values = (pal),name=NULL)+
coord_map(projection = "albers",lat0=41,lat1=45,ylim = c(23.5,48))+
guides(fill = guide_legend(nrow=1))+
labs(x = NULL, y = NULL,
title = "Adoptable Dog Breeds",
subtitle = "Most common primary breed of shelter dogs per state on Sep 20, 2019")+
theme(plot.margin = unit(c(5,0,5,0), "points"))
# Step 5. save
#--- --- --- --- --- --- --- --- --- ---
ggsave(here::here("output","Dec17.19","breedmap.png"), height = 5,width = 8.2)
dogs_cleaned <- dogs_cleaned %>%
select(c(id,breed_primary,size,origin,contact_country,rescue_location)) %>%
filter(origin %in% state.name) # pull only those originating from US states
#clean up place of origin - recognizable state names/abbrevations or country names
dogs_cleaned <- dogs_cleaned %>%
filter(found %in% state.name | found %in% state.abb |
manual %in% state.name | manual %in% state.abb |
found %in% codelist$country.name.en |
manual %in% codelist$country.name.en |
found == "DC" |
manual == "DC")
dog_travel <- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2019/2019-12-17/dog_travel.csv')
dog_descriptions <- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2019/2019-12-17/dog_descriptions.csv')
dogs_total <- dog_travel %>%
select(-c(contact_city, contact_state, description)) %>%
left_join(dog_descriptions, by="id")
rm(dog_travel,dog_descriptions)
#messy - lots of repeats/missing data - try to clean up
dogs_cleaned <- dogs_total %>% distinct() %>% #keep only distinct rows
group_by(id) %>%
mutate(id_count = n()) %>% #count # of times this ID shows up
ungroup() %>%
filter(id_count == 1 | (id_count >= 2 & !is.na(manual))) %>% #if we have repeats, keep only those manually entered
select(-c(id_count, color_tertiary, house_trained,
declawed, shots_current, tags, photo,
status, accessed, type, stateQ,
breed_unknown, still_there)) %>% #we don't need id_count anymore, also remove other variables we don't need
filter(!grepl("foster", tolower(name))) %>% #some are ads for foster homes needed - remove
arrange(id) #order by #ID
rm(dogs_total)
#final step of filtering - if multiple id matches, keep only the first
lastid <- 0
idx_to_remove <- c()
for (i in 1:nrow(dogs_cleaned)){
thisid <- dogs_cleaned$id[i]
if (thisid == lastid){
idx_to_remove <- c(idx_to_remove, i)
}
lastid <- thisid
}
dogs_cleaned <- dogs_cleaned[-idx_to_remove,]#remove these repeats
rm(i,lastid,idx_to_remove)
#clean up place of origin - recognizable state names/abbrevations or country names
dogs_cleaned <- dogs_cleaned %>%
filter(found %in% state.name | found %in% state.abb |
manual %in% state.name | manual %in% state.abb |
found %in% codelist$country.name.en |
manual %in% codelist$country.name.en |
found == "DC" |
manual == "DC")
#clean up place of origin - recognizable state names/abbrevations or country names
dogs_cleaned <- dogs_cleaned %>%
filter(found %in% state.name | found %in% state.abb |
manual %in% state.name | manual %in% state.abb |
found %in% codelist$country.name.en |
manual %in% codelist$country.name.en |
found == "DC" |
manual == "DC")
dogs_cleaned <- dogs_cleaned[-idx_to_remove,]#remove these repeats
#messy - lots of repeats/missing data - try to clean up
dogs_cleaned <- dogs_total %>% distinct() %>% #keep only distinct rows
group_by(id) %>%
mutate(id_count = n()) %>% #count # of times this ID shows up
ungroup() %>%
filter(id_count == 1 | (id_count >= 2 & !is.na(manual))) %>% #if we have repeats, keep only those manually entered
select(-c(id_count, color_tertiary, house_trained,
declawed, shots_current, tags, photo,
status, accessed, type, stateQ,
breed_unknown, still_there)) %>% #we don't need id_count anymore, also remove other variables we don't need
filter(!grepl("foster", tolower(name))) %>% #some are ads for foster homes needed - remove
arrange(id) #order by #ID
dog_travel <- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2019/2019-12-17/dog_travel.csv')
dog_descriptions <- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2019/2019-12-17/dog_descriptions.csv')
dogs_total <- dog_travel %>%
select(-c(contact_city, contact_state, description)) %>%
left_join(dog_descriptions, by="id")
#messy - lots of repeats/missing data - try to clean up
dogs_cleaned <- dogs_total %>% distinct() %>% #keep only distinct rows
group_by(id) %>%
mutate(id_count = n()) %>% #count # of times this ID shows up
ungroup() %>%
filter(id_count == 1 | (id_count >= 2 & !is.na(manual))) %>% #if we have repeats, keep only those manually entered
select(-c(id_count, color_tertiary, house_trained,
declawed, shots_current, tags, photo,
status, accessed, type, stateQ,
breed_unknown, still_there)) %>% #we don't need id_count anymore, also remove other variables we don't need
filter(!grepl("foster", tolower(name))) %>% #some are ads for foster homes needed - remove
arrange(id) #order by #ID
#final step of filtering - if multiple id matches, keep only the first
lastid <- 0
idx_to_remove <- c()
for (i in 1:nrow(dogs_cleaned)){
thisid <- dogs_cleaned$id[i]
if (thisid == lastid){
idx_to_remove <- c(idx_to_remove, i)
}
lastid <- thisid
}
dogs_cleaned <- dogs_cleaned[-idx_to_remove,]#remove these repeats
#clean up place of origin - recognizable state names/abbrevations or country names
dogs_cleaned <- dogs_cleaned %>%
filter(found %in% state.name | found %in% state.abb |
manual %in% state.name | manual %in% state.abb |
found %in% codelist$country.name.en |
manual %in% codelist$country.name.en |
found == "DC" |
manual == "DC")
#consolidate origin into one column
dogs_cleaned$origin <- dogs_cleaned$manual
dogs_cleaned[which(is.na(dogs_cleaned$manual)),]$origin <- dogs_cleaned[which(is.na(dogs_cleaned$manual)),]$found
dogs_cleaned <- dogs_cleaned %>% select(-c(manual, found))
#convert abbreviations to state names
dogs_cleaned$rescue_location <- state.name[match(dogs_cleaned$contact_state, state.abb)]
dogs_cleaned[which(dogs_cleaned$contact_state == "DC"),]$rescue_location <- "Washington DC"
dogs_cleaned[which(dogs_cleaned$contact_country == "KY"),]$rescue_location <- "Kentucky"
for (i in 1:nrow(dogs_cleaned)){
if (dogs_cleaned$origin[i] %in% state.abb){
dogs_cleaned$origin[i] <- state.name[match(dogs_cleaned$origin[i], state.abb)]
}
if (dogs_cleaned$origin[i] == "DC"){
dogs_cleaned$origin[i] = "Washington DC"
}
}
dogs_cleaned <- dogs_cleaned %>%
select(c(id,breed_primary,size,origin,contact_country,rescue_location)) %>%
filter(origin %in% state.name) # pull only those originating from US states
exports <- data.frame(table(dogs_cleaned$origin, dogs_cleaned$rescue_location))
# this makes a df of moves from state to state, we will use it to make a circular export graph
exports
## Separate states into regions
#--- --- --- --- --- --- --- --- --- --- ---
{
northeast <- c("Connecticut","Maine","Massachusetts","New Hampshire","Rhode Island","Vermont","New Jersey","New York","Pennsylvania")
midwest <- c( "Indiana", "Illinois", "Michigan", "Ohio", "Wisconsin", "Iowa","Nebraska",
"Kansas", "North Dakota", "Minnesota", "South Dakota", "Missouri")
southatlantic <- c("Maryland","Delaware","Washington DC","West Virginia","Virginia","North Carolina","South Carolina","Georgia","Florida")
southgulf <- c("Kentucky","Tennessee","Alabama","Mississippi","Arkansas","Louisiana","Oklahoma","Texas")
west <- c("Arizona","Colorado","Idaho","New Mexico","Montana",
"Utah","Nevada","Wyoming","Alaska","California","Hawaii","Oregon","Washington")
}
statelist <- c(northeast,southatlantic,southgulf,midwest,west) # order them this way, rather than alphabetically
# color tools
#--- --- --- --- --- --- --- --- --- --- --- ---
pal <- pnw_palette("Starfish",5) # build a palette
totalsegs <- unique(abind::abind(unique(exports$Var1),unique(exports$Var2)))
grid.col <- c( # make a vector colors of each state (colored by region). Not all states listed show up in segments, so this was kind of weird
rep( pal[1], times = length(totalsegs[totalsegs %in% northeast])),
rep( pal[2], times = length(totalsegs[totalsegs %in% southatlantic])),
rep( pal[3], times = length(totalsegs[totalsegs %in% southgulf])),
rep( pal[4], times = length(totalsegs[totalsegs %in% midwest])),
rep( pal[5], times = length(totalsegs[totalsegs %in% west]))
)
circos.clear()
# graph patameters
#--- --- --- --- --- --- --- --- --- ---
par(
mar = c(1, 0, 3, 0),    # Margin around chart
bg = c("grey15"),     # background color
family="Helvetica Neue Light"
)
# chord diagram
#--- --- --- --- --- --- --- --- --- ---
chordDiagram(x=exports, order=statelist,
directional = 1,
#  direction.type = "arrows",
diffHeight = F,
preAllocateTracks = list(list(track.height=  uh(3,"mm")   ), # outside track for names
list(track.height=  uh(10,"mm")    )), # middle track for regions
self.link = 1,
annotationTrack = "grid",
grid.col = grid.col
)
#highlight regions in track 2
#--- --- --- --- --- --- --- --- --- --- --- ---
highlight.sector(northeast, track.index = 1, col = pal[1],
text = "Northeast", cex = 0.7, text.col = "white", niceFacing = TRUE)
chordDiagram(check,
preAllocateTracks = list(list(track.height=  uh(3,"mm")), # outside track for names
list(track.height=  uh(10,"mm"))), # middle track for regions
grid.col = col.pal)
exports
check <- matrix(random_sample,nrow=4,
dimnames = list(c("Freebayes","Lofreq","Varscan", "BreseQ"),
c("breseq","BWA","Minimap")))
check
check %>%
at_tibble()
check %>%
as_tibble()
data.frame(breseq=sample(100:200))
data.frame(breseq=sample(100:200,4))
data.frame(Freebayes=sample(100:200,4), BCFtools=sample(100:200,4),
Lofreq=sample(200:250,4), Varscan=sample(300:350,5),
Mappers=c("Breseq","BWA","Minimap"))
data.frame(Freebayes=sample(100:200,3), BCFtools=sample(100:200,3),
Lofreq=sample(200:250,3), Varscan=sample(300:350,3),
Mappers=c("Breseq","BWA","Minimap"))
data.frame(Freebayes=sample(100:200,3), BCFtools=sample(100:200,3),
Lofreq=sample(200:250,3), Varscan=sample(300:350,3),
Mappers=c("Breseq","BWA","Minimap")) %>%
pivot_longer(!Mappers, names_to = "SNP_caller")
test.df <- data.frame(Freebayes=sample(100:200,3), BCFtools=sample(100:200,3),
Lofreq=sample(200:250,3), Varscan=sample(300:350,3),
Mappers=c("Breseq","BWA","Minimap")) %>%
pivot_longer(!Mappers, names_to = "SNP_caller")
col.pal = c(Freebayes="#00798c",Lofreq="#d1495b",Varscan="#edae49",BCFtools="#66a182",
Breseq="#2e4057", BWA="#8d96a3", Minimap= "#c9cdd4")
chordDiagram(test.df)
chordDiagram(test.df, order=SNP_caller)
chordDiagram(test.df, order="SNP_caller")
chordDiagram(test.df)
statelist
SNP_callers=test.df$SNP_caller
chordDiagram(test.df, order=SNP_callers)
SNP_callers=test.df$SNP_caller
chordDiagram(test.df, order=SNP_callers)
SNP_callers
SNP_callers=test.df$SNP_caller %>%
unique()
SNP_callers
chordDiagram(test.df, order=SNP_callers)
test.df %>%
distinct(SNP_caller)
SNP_callers <- test.df %>%
distinct(SNP_caller)
SNP_callers <- test.df %>%
distinct(SNP_caller)
SNP_callers
chordDiagram(test.df, order=SNP_callers)
SNP_callers <- test.df %>%
distinct(SNP_caller) %>%
SNP_callers
SNP_callers <- test.df %>%
distinct(SNP_caller) %>%
.$SNP_caller
SNP_callers
chordDiagram(test.df, order=SNP_callers)
statelist
SNP_callers <- test.df %>%
distinct(SNP_caller) %>%
.$SNP_caller %>%
as.matrix()
SNP_callers
chordDiagram(test.df, order=SNP_callers)
SNP_callers <- test.df %>%
distinct(SNP_caller) %>%
.$SNP_caller
SNP_callers <- test.df %>%
distinct(SNP_caller)
SNP_callers
SNP_callers$SNP_caller
test.df
)
SNP_callers <- test.df %>%
distinct(SNP_caller, .keep_all = TRUE)
SNP_callers
SNP_callers$SNP_caller
str(statelist)
str(SNP_callers$SNP_caller)
SNP_callers <- test.df %>%
distinct(SNP_caller, .keep_all = TRUE)
SNP_callers
chordDiagram(test.df, order=SNP_callers)
SNP_callers <- test.df %>%
distinct(SNP_caller, .keep_all = TRUE) %>%
.$SNP_caller
SNP_callers
chordDiagram(test.df, order=SNP_callers)
col.pal
SNP_callers <- test.df %>%
distinct(SNP_caller, .keep_all = TRUE)
SNP_callers
SNP_callers = c(Freebayes,Lofreq,Varscan,BCFtools,Breseq,BWA,Minimap)
SNP_callers = c("Freebayes","Lofreq","Varscan","BCFtools","Breseq","BWA","Minimap")
SNP_callers
chordDiagram(test.df, order=SNP_callers)
{
SNP_callers = c("Freebayes","Lofreq","Varscan","BCFtools","Breseq","BWA","Minimap")
Mappers=c("Breseq","BWA","Minimap")
}
info=c(SNP_callers,Mappers)
info
{
SNP_callers = c("Freebayes","Lofreq","Varscan","BCFtools","Breseq","BWA","Minimap")
Mappers=c("Breseq","BWA","Minimap")
}
info=c(SNP_callers,Mappers)
info
chordDiagram(test.df, order=info)
highlight.sector(SNP_callers, track.index = 1, col = pal[1],
text = "Northeast", cex = 0.7, text.col = "white", niceFacing = TRUE)
highlight.sector(SNP_callers, track.index = 1, col = pal[1],
text = "SNP_callers", cex = 0.7, text.col = "white", niceFacing = TRUE)
chordDiagram(test.df, order=info,
annotationTrack = "grid")
highlight.sector(SNP_callers, track.index = 1, col = pal[1],
text = "SNP_callers", cex = 0.7, text.col = "white", niceFacing = TRUE)
chordDiagram(test.df, order=info,
annotationTrack = "grid")
highlight.sector(SNP_callers, track.index = 1, col = pal[1],
text = "SNP_callers", cex = 0.7, text.col = "white", niceFacing = TRUE)
chordDiagram(test.df, order=info,
annotationTrack = "grid",
diffHeight = F,
preAllocateTracks = list(list(track.height=  uh(3,"mm")   ), # outside track for names
list(track.height=  uh(10,"mm")    )), # middle track for regions
self.link = 1)
highlight.sector(SNP_callers, track.index = 1, col = pal[1],
text = "SNP_callers", cex = 0.7, text.col = "white", niceFacing = TRUE)
highlight.sector(SNP_callers, track.index = 0.5, col = pal[1],
text = "SNP_callers", cex = 0.7, text.col = "white", niceFacing = TRUE)
chordDiagram(test.df, order=info,
directional = 1,
annotationTrack = "grid",
diffHeight = F,
preAllocateTracks = list(list(track.height=  uh(3,"mm")   ), # outside track for names
list(track.height=  uh(10,"mm")    )), # middle track for regions
self.link = 1)
highlight.sector(SNP_callers, track.index = 1, col = pal[1],
text = "SNP_callers", cex = 0.7, text.col = "white", niceFacing = TRUE)
highlight.sector(Mappers, track.index = 1, col = pal[2],
text = "South Atlantic", cex = 0.7, text.col = "white", niceFacing = TRUE)
{
SNP_callers = c("Freebayes","Lofreq","Varscan","BCFtools")
Mappers=c("Breseq","BWA","Minimap")
}
info=c(SNP_callers,Mappers)
info=c(SNP_callers,Mappers)
chordDiagram(test.df, order=info,
directional = 1,
annotationTrack = "grid",
diffHeight = F,
preAllocateTracks = list(list(track.height=  uh(3,"mm")   ), # outside track for names
list(track.height=  uh(10,"mm")    )), # middle track for regions
self.link = 1)
highlight.sector(SNP_callers, track.index = 1, col = pal[1],
text = "SNP_callers", cex = 0.7, text.col = "white", niceFacing = TRUE)
highlight.sector(Mappers, track.index = 1, col = pal[2],
text = "South Atlantic", cex = 0.7, text.col = "white", niceFacing = TRUE)
chordDiagram(test.df, order=info,
directional = 1,
annotationTrack = "grid",
diffHeight = F,
preAllocateTracks = list(list(track.height=  uh(3,"mm")), # outside track for names
list(track.height=  uh(10,"mm"))), # middle track for regions
self.link = 1)
highlight.sector(SNP_callers, track.index = 1, col = pal[1],
text = "SNP_callers", cex = 0.7, text.col = "white", niceFacing = TRUE)
highlight.sector(Mappers, track.index = 1, col = pal[2],
text = "South Atlantic", cex = 0.7, text.col = "white", niceFacing = TRUE)
chordDiagram(test.df, order=info,
directional = 1,
annotationTrack = "grid",
diffHeight = F,
preAllocateTracks = list(list(track.height=  uh(3,"mm")), # outside track for names
list(track.height=  uh(10,"mm"))), # middle track for regions
self.link = 1,
grid.col =col.pal)
highlight.sector(SNP_callers, track.index = 1, col = pal[1],
text = "SNP_callers", cex = 0.7, text.col = "white", niceFacing = TRUE)
highlight.sector(Mappers, track.index = 1, col = pal[2],
text = "South Atlantic", cex = 0.7, text.col = "white", niceFacing = TRUE)
title(main = list("Shelter Dog Trade Network",
cex=2.4,
col="grey75"))
title(main = list("Differences between callers and mappers",
cex=2.4,
col="grey75"))
info=c(SNP_callers,Mappers)
chordDiagram(test.df, order=info,
directional = 1,
annotationTrack = "grid",
diffHeight = F,
preAllocateTracks = list(list(track.height=  uh(3,"mm")), # outside track for names
list(track.height=  uh(10,"mm"))), # middle track for regions
self.link = 1,
grid.col =col.pal)
circus.clear()
circos.clear()
# color each category
col.pal = c(Freebayes="#00798c",Lofreq="#d1495b",Varscan="#edae49",BCFtools="#66a182",
Breseq="#2e4057", BWA="#8d96a3", Minimap= "#c9cdd4")
{
SNP_callers = c("Freebayes","Lofreq","Varscan","BCFtools")
Mappers=c("Breseq","BWA","Minimap")
}
info=c(SNP_callers,Mappers)
chordDiagram(test.df, order=info,
directional = 1,
annotationTrack = "grid",
diffHeight = F,
preAllocateTracks = list(list(track.height=  uh(3,"mm")), # outside track for names
list(track.height=  uh(10,"mm"))), # middle track for regions
self.link = 1,
grid.col =col.pal)
highlight.sector(SNP_callers, track.index = 1, col = pal[1],
text = "SNP_callers", cex = 0.7, text.col = "white", niceFacing = TRUE)
highlight.sector(Mappers, track.index = 1, col = pal[2],
text = "South Atlantic", cex = 0.7, text.col = "white", niceFacing = TRUE)
par(
mar = c(1, 0, 3, 0),    # Margin around chart
bg = c("grey15"),     # background color
family="Helvetica Neue Light"
)
